<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.6.2"><meta name="generator" content="Jekyll v4.1.1" /><meta property="og:title" content="Introducing Rustybot (part 1 of n)" /><meta name="author" content="drmorr" /><meta property="og:locale" content="en_US" /><meta name="description" content="N.B. This is the first part of a series about programming an Arduino robot using Rust’s async primitives (Part 1, 2). If you just want to skip to the source code, click here." /><meta property="og:description" content="N.B. This is the first part of a series about programming an Arduino robot using Rust’s async primitives (Part 1, 2). If you just want to skip to the source code, click here." /><link rel="canonical" href="https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/" /><meta property="og:url" content="https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/" /><meta property="og:site_name" content="Object Disoriented" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-21T23:30:00-08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Introducing Rustybot (part 1 of n)" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@type":"BlogPosting","url":"https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/","dateModified":"2021-01-04T23:06:20-08:00","datePublished":"2020-12-21T23:30:00-08:00","headline":"Introducing Rustybot (part 1 of n)","mainEntityOfPage":{"@type":"WebPage","@id":"https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/"},"author":{"@type":"Person","name":"drmorr"},"description":"N.B. This is the first part of a series about programming an Arduino robot using Rust’s async primitives (Part 1, 2). If you just want to skip to the source code, click here.","@context":"https://schema.org"}</script><title>Introducing Rustybot (part 1 of n) | Object Disoriented</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/robot.svg" alt="this robot is confused" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Object Disoriented</a></div><div class="site-subtitle font-italic">When OOP becomes OOPS</div><div class="site-about">Building robots with Rust. Navel-gazing about tech. Doing buzzwords on Kubernetes.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/drmorr0" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['drmorr','evokwonder.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Introducing Rustybot (part 1 of n)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Introducing Rustybot (part 1 of n)</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 21, 2020, 11:30 PM -0800" > Dec 21, 2020 <i class="unloaded">2020-12-21T23:30:00-08:00</i> </span> by <span class="author"> drmorr </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 4, 2021, 11:06 PM -0800" > Jan 4 <i class="unloaded">2021-01-04T23:06:20-08:00</i> </span></div></div><div class="post-content"><blockquote><p>N.B. This is the first part of a series about programming an Arduino robot using Rust’s async primitives (Part 1, <a href="https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-2/">2</a>). If you just want to skip to the source code, click <a href="https://github.com/drmorr0/rustybot">here</a>.</p></blockquote><h2 id="so-you-want-to-build-a-robot">So you want to build a robot?</h2><p>It all started when I decided I was going to build a quadcopter. But not just any quadcopter, I was going to get all the parts and put it together myself! And then I was going to write the flight control system (in Rust, of course) so that it could fly autonomously and do tasks for me, like flying over to the front door to see who just rang my doorbell.</p><p>That’s doable in a weekend, right? Right?</p><details> <summary>click to expand</summary><figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://media.giphy.com/media/NaboQwhxK3gMU/giphy.gif" /><figcaption> This is from The Walking Dead so I can only assume that this dude gets his face violently ripped off right after he says this.</figcaption></figure></details><p>So anyways, that’s how I found myself building a control system in Rust for a robot that stays on the ground and is not powered by batteries that might spontaneously combust.</p><h2 id="the-basics-hardware-and-software">The basics: hardware and software</h2><p>I’m not super-interested in the hardware side of things and I wanted to get right to the software for the control system, so I bought an <a href="https://store.arduino.cc/usa/arduino-uno-smd-rev3">Arduino Uno</a> and a <a href="https://www.pololu.com/product/2510">pre-assembled Zumo robot body</a> that came with a bunch of features I knew I’d want to learn how to use, including an array of IR sensors I can use for line detection and a 3-axis accelerometer for determining spatial orientation. I also purchased an <a href="https://www.adafruit.com/product/172">ultrasonic rangefinder</a> for long-range object detection.</p><p>The Arduino Uno uses an Atmel Atmega328p AVR microcontroller, and I really wanted to not write code in C; fortunately for me, AVR support for Rust was merged into nightly <a href="http://www.avr-rust.com">earlier this year</a>! So I was pretty much golden and could get right to the fun stuff. All I had to figure out how to program the thing!</p><p>After looking around the various embedded Rust projects, I ended up using <a href="https://github.com/Rahix">@Rahix’s</a> <a href="https://github.com/Rahix/avr-hal"><code class="language-plaintext highlighter-rouge">avr-hal</code></a> crate, which is in turn based off the <a href="https://github.com/rust-embedded/embedded-hal"><code class="language-plaintext highlighter-rouge">embedded-hal</code></a> project by the <a href="https://github.com/rust-embedded/wg#the-hal-team">embedded Rust team</a> (n.b. I briefly looked at the <a href="https://github.com/avr-rust/ruduino"><code class="language-plaintext highlighter-rouge">ruduino</code></a> project, but I was having trouble getting it to compile and I wanted to keep some of the abstractions less tied to the AVR processor, since I’m imagining at some point I’m going to need to move to a Cortex ARM processor – especially when I eventually build my quadcopter :D)</p><p>The first task was to just get the <a href="https://github.com/Rahix/avr-hal/blob/master/boards/arduino-uno/examples/uno-blink.rs">blinky example</a> to compile. This took a bit of finagling, particularly since I’m running Windows but doing all my development on the Windows Subsystem for Linux. I don’t remember all the different combinations I tried, but eventually settled on having the source stored on the Windows host, but using <code class="language-plaintext highlighter-rouge">rustc</code> from Ubuntu for compilation. I also tried to get VSCode to work with this setup, but was never able to successfully get it to work, so gave up. Anyways, once I got blinky working, I started exploring some of the robot peripherals. The Zumo libraries of course are all in C, and I wasn’t wild about trying to do some weird cross-language linking or whatever, so decided the easiest thing to do would be to just port them to Rust. I got the IR sensor array working and the motor drivers working, and then, like any software engineer worth their salt, decided it was time to rewrite the entire project from scratch! Which brings us to the meat of this series of blog posts, embedded asynchronous robotics with Rust!</p><details> <summary>click to expand</summary><figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://media.giphy.com/media/xT5LMCJyj3w0XFPbtS/giphy.gif" /><figcaption>Why, yes they are, Bob. Yes, they are.</figcaption></figure></details><h2 id="embedded-asynchronous-robotics-with-rust">Embedded asynchronous robotics with Rust</h2><p>Over the course of getting the sensors and motors to work, I made two realizations that led me down the path of asynchronous programming: the first was that I was spending a <em>lot</em> of time calling <code class="language-plaintext highlighter-rouge">arduino_uno::delay_ms</code>, which just didn’t seem very efficient to me. Every component (the motors, the sensors, even the LED) requires some time to wait for the hardware to catch up. Two examples: I wanted to avoid putting undue strain on the motors and the chassis of the robot by not making abrupt changes in velocity, so I implemented a system that would allow the controller to set a target value and then it would gradually adjust the motor’s actual speed to match the target. Second, the IR sensor array I’m using works by turning on some infrared LEDs and then measuring the time it takes for the light to bounce back – the longer it takes, the darker the surface, more or less.</p><p>Now, from a power-draw perspective, the motors far outweigh anything that I’m doing on the Arduino board, but it still didn’t sit well with me that I’m just busy-looping away in all these different components. More importantly, though I wanted to build something that was able to respond to inputs immediately, which busy-looping doesn’t do. If the sensors detect something, but I’m in the middle of the motor-update loop, I have to wait until the motors finish their work before handling the sensor input. Now in “normal” computers we have threads and a CPU scheduler to handle this, but for my purposes that’s overkill. Since I’m going to be in charge of everything running on the bot, <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a> is good enough, and luckily for me, Rust has just <a href="https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html">standardized</a> on how to do this in the language!</p><p>I’ve done a <em>bit</em> of asynchronous work in the past, but never really understood the mechanisms under the hood; so this project definitely threw me into the deep end! I modelled my approach off two sources, the excellent <a href="https://lights0123.com/blog/2020/07/25/async-await-for-avr-with-rust/">blogpost</a> by Ben Schattinger, and the work by the <a href="https://github.com/rust-embedded-community/async-on-embedded">async-on-embedded</a> team. These were great starting points, but I still ran into a bunch of gotchas along the way. So I’m going to try to walk through all the steps I took and how I resolved them, and hopefully maybe help some other folks as well.</p><h2 id="hold-up-how-does-this-asynchronous-thing-work-anyways">Hold up, how does this asynchronous thing work, anyways???</h2><p>I don’t want to spend a <em>ton</em> of time in the blog post going over asynchronous programming in general; there’s plenty of resources out there for that, such as the <a href="https://rust-lang.github.io/async-book/">async Rust book</a>. But there’s no “official” way to do async on AVR at the time of writing, so I needed to get my hands dirty a little bit. First, I needed to understand the basics of how Rust does asynchronous programming.</p><details> <summary>click to expand</summary><figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://media.giphy.com/media/e7i6KJU8jBMvS/giphy.gif" /><figcaption>Just so we're all clear, this is <i>not</i> my robot.</figcaption></figure></details><p>The core concept for async programming is pretty easy to understand: we’ve got a bunch of tasks and an executor which is responsible for running those tasks, and when a task doesn’t have any work to do it yields control back to the executor. This is <em>cooperative</em> multitasking because the tasks have to work together: if one task never yields, none of the other tasks will run (in contrast to threaded multitasking, in which the executor will yank control back from tasks whenever it feels like). Every language implements this a little bit differently, but in Rust the core primitive is a <code class="language-plaintext highlighter-rouge">Future</code>; a <code class="language-plaintext highlighter-rouge">Future</code> object has a pretty simple interface<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>:</p><div class="language-rust highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span>
    <span class="k">mut</span> <span class="k">self</span><span class="p">:</span> <span class="nn">core</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="n">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="n">Self</span><span class="o">&gt;</span><span class="p">,</span> 
    <span class="n">ctx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">core</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">Context</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">core</span><span class="p">::</span><span class="nn">task</span><span class="p">::</span><span class="n">Poll</span><span class="o">&lt;</span><span class="nn">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span>
</pre></table></code></div></div><p>Ok, hang on a sec, there’s actually a lot in here that needs unpacking. Let’s start with the return value; every future returns a <code class="language-plaintext highlighter-rouge">core::task::Poll&lt;T&gt;</code>, which is an enum with two possible values, <code class="language-plaintext highlighter-rouge">Pending</code> and <code class="language-plaintext highlighter-rouge">Ready(T)</code>. The idea here is that periodically the executor will poll each of the tasks by calling this function, and if the future has finished, it will return <code class="language-plaintext highlighter-rouge">Ready(T)</code>, where <code class="language-plaintext highlighter-rouge">T</code> is the type of the expected output. If the future has more work to do, it will (optionally) advance the state of the future (i.e., do some more work), and then return <code class="language-plaintext highlighter-rouge">Pending</code>. If the future breaks the cooperative multitasking contract (for example, by sticking an infinite loop in <code class="language-plaintext highlighter-rouge">poll</code>), then control will never get yielded back to the executor and none of the other tasks will execute.</p><p>The key thing to wrap your head around with async programming in Rust is that <em>every</em> asynchronous task in Rust is a <code class="language-plaintext highlighter-rouge">Future</code> (and thus has a <code class="language-plaintext highlighter-rouge">poll</code> method), whether it’s obvious or not. When you use the <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> keywords, all you’re doing is taking advantage of some syntactic sugar that has been built into the Rust compiler; under the hood, Rust converts that function into a <code class="language-plaintext highlighter-rouge">Future</code> with a <code class="language-plaintext highlighter-rouge">poll</code> method. This future object is actually a mini state machine, where the current state represents where we last paused and what work we need to do next. I’m not going to go into details about how this works here, there’s plenty of other excellent blogs out there on the topic (such as <a href="https://tmandry.gitlab.io/blog/posts/optimizing-await-1/">this one</a>). Instead, what I want to focus on here is how we can get these futures running on AVR processor.</p><h3 id="pin-the-tail-on-the-selfie">Pin the tail on the Selfie</h3><p>So, how can we get these futures running on an AVR processor? Let’s go back to that polling function; the first argument in there is a mutable reference to <code class="language-plaintext highlighter-rouge">self</code>, just like we expect, but it’s got this funky <code class="language-plaintext highlighter-rouge">Pin</code> type – what’s going on there? Well, remember, under the hood, futures are mini state machines, and they need someplace to store their state, specifically someplace that isn’t the stack (you can imagine things would go horribly wrong when the stack frame containing the future’s state gets popped). So the <code class="language-plaintext highlighter-rouge">Pin</code> type just promises the compiler that the data being pointed to won’t change memory locations. There are a lot of subtleties here, but for our purposes, there’s two types of things that are <code class="language-plaintext highlighter-rouge">Pin</code>:</p><ol><li><code class="language-plaintext highlighter-rouge">static</code> objects<li>Dynamically-allocated objects (as long as nothing moves them around in memory)</ol><p>The first is easy; my robot code has a bunch of <code class="language-plaintext highlighter-rouge">static mut</code> objects sprinkled around to keep track of the state of various futures (e.g., the <a href="https://github.com/drmorr0/rustybot/blob/34981a6312b836c2dc62a7a6e8db8724442ada79/src/uno/zumo_sensors.rs#L24"><code class="language-plaintext highlighter-rouge">SENSOR_TRIGGERED</code></a> bitfield keeps track of the state of the IR sensors on the robot).</p><p>“But wait!?” I hear you saying. “<code class="language-plaintext highlighter-rouge">static mut</code> objects are <code class="language-plaintext highlighter-rouge">unsafe</code>, and also they’re bad!!!!” And yea, you’re probably right; so the pattern I’ve tried to adopt in my code is to only have <code class="language-plaintext highlighter-rouge">static mut</code> variables that need to be referenced from an interrupt context. Everything else should be dynamically allocated.</p><p>“But wait!?” I hear you saying again. “You don’t have a heap, how do you dynamically allocate anything???” Well, the obvious answer here is: write a heap. In my code, you’ll see that all my futures are wrapped in calls to <code class="language-plaintext highlighter-rouge">Allocator::get().new(future())</code>; the <code class="language-plaintext highlighter-rouge">Allocator</code> is some code I stole with slight modification from the <a href="https://github.com/rust-embedded-community/async-on-embedded/blob/master/async-embedded/src/alloc.rs">async-on-embedded team</a>. This code implements a simple <a href="https://os.phil-opp.com/allocator-designs/#bump-allocator">bump allocator</a>, which grabs an array of memory and provides a simple interface for storing things <code class="language-plaintext highlighter-rouge">static</code>-ally in that array. It never de-allocates anything and never moves anything around, so we can be sure that this satisfies <code class="language-plaintext highlighter-rouge">Pin</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>.</p><h3 id="context--context--is-there-a-context-in-here">Context? Context? Is there a Context in here?</h3><details> <summary>click to expand</summary><figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="https://media.giphy.com/media/Xs2ry2K0ADD7G/giphy.gif" /></figure></details><p>The last thing I’m going to cover in this post is the second argument to <code class="language-plaintext highlighter-rouge">poll</code>, which caused me quite a bit of confusion. The <a href="https://doc.rust-lang.org/core/task/struct.Context.html">Rust docs</a> simply say</p><blockquote><p>The <code class="language-plaintext highlighter-rouge">Context</code> of an asynchronous task. Currently, Context only serves to provide access to a <code class="language-plaintext highlighter-rouge">&amp;Waker</code> which can be used to wake the current task.</p></blockquote><p>Ok… I guess that’s helpful, but what’s a <code class="language-plaintext highlighter-rouge">Waker</code>?</p><blockquote><p>A <code class="language-plaintext highlighter-rouge">Waker</code> is a handle for waking up a task by notifying its executor that it is ready to be run. This handle encapsulates a <code class="language-plaintext highlighter-rouge">RawWaker</code> instance, which defines the executor-specific wakeup behavior.</p></blockquote><p>Well, ok. What’s a <code class="language-plaintext highlighter-rouge">RawWaker</code>?</p><blockquote><p>A <code class="language-plaintext highlighter-rouge">RawWaker</code> allows the implementor of a task executor to create a Waker which provides customized wakeup behavior. It consists of a data pointer and a virtual function pointer table (vtable) that customizes the behavior of the <code class="language-plaintext highlighter-rouge">RawWaker</code>.</p></blockquote><p>Alright, we’re getting pretty darned far down this rabbit hole now, but I’ll bite. What’s the vtable do?</p><blockquote><p>A virtual function pointer table (vtable) that specifies the behavior of a <code class="language-plaintext highlighter-rouge">RawWaker</code>. The pointer passed to all functions inside the vtable is the data pointer from the enclosing <code class="language-plaintext highlighter-rouge">RawWaker</code> object. The functions inside this struct are only intended to be called on the data pointer of a properly constructed <code class="language-plaintext highlighter-rouge">RawWaker</code> object from inside the <code class="language-plaintext highlighter-rouge">RawWaker</code> implementation. Calling one of the contained functions using any other data pointer will cause undefined behavior.</p></blockquote><p>I don’t know if I’m just dense, but this is all clear as mud to me. How the heck does this <code class="language-plaintext highlighter-rouge">Context</code> get constructed? Why are there twenty billion layers of indirection here? What’s the data pointer inside the <code class="language-plaintext highlighter-rouge">Waker</code> supposed to be? How does that get added? The async Rust book isn’t much help here either, because it makes all these assumptions that you’ll have things like, oh, I dunno, threads and stuff. Which we definitely don’t have here.</p><p>So anyways, after many hours of spinning myself around in circles and banging my head on my keyboard, I finally got it. Let’s answer one question first: why do we have so many layers of indirection? It has to do with that <code class="language-plaintext highlighter-rouge">data</code> pointer – the Rust executors don’t have any idea what type of tasks they’re running, so everything has to be accessed via untyped pointers, which is clearly <code class="language-plaintext highlighter-rouge">unsafe</code>. So that’s what all the <code class="language-plaintext highlighter-rouge">Raw*</code> functions do, and the un-<code class="language-plaintext highlighter-rouge">Raw</code> versions are wrappers so that we don’t have to sprinkle <code class="language-plaintext highlighter-rouge">unsafe</code> everywhere in our code. So far pretty standard. The only design I question is whether the <code class="language-plaintext highlighter-rouge">Context</code> object is really necessary; I assume it’s there so that we can maybe someday pass additional metadata into the tasks, but right now it’s just this extra layer that doesn’t do anything.</p><p>The other thing that’s a bit confusing is that we have a nesting of <code class="language-plaintext highlighter-rouge">Context -&gt; Waker -&gt; RawWaker</code>, but you actually <em>construct</em> this in reverse order. You have to create a <code class="language-plaintext highlighter-rouge">RawWaker</code> object, and then call <code class="language-plaintext highlighter-rouge">Waker::from_raw</code> on it, and then you call <code class="language-plaintext highlighter-rouge">Context::from_waker</code> on the <code class="language-plaintext highlighter-rouge">Waker</code>. I guess this is fine, but after going around in so many circles it was one more thing that I had to keep going back to. “Wait, <em>how</em> do I construct a context, again??”</p><p>Anyways, once I sorted out all the layers here, things got a lot easier. We’ll discuss this more next time, but for now we can just say that for my code, every <code class="language-plaintext highlighter-rouge">Future</code> gets an attached <code class="language-plaintext highlighter-rouge">id</code> field, and the <code class="language-plaintext highlighter-rouge">Context</code> object stores a pointer to this ID. That way, when we need to decide what future to wake up, we can just reference the stored ID pointer and pass that along.</p><h2 id="wrapping-up">Wrapping up</h2><p>Just for completeness’ sake, let me diagram where we’re going in the next post. I’m going to show you how I created an executor for AVR, which more-or-less does the following:</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">future</span><span class="p">.</span><span class="n">not_ready</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">context</span> <span class="o">=</span> <span class="n">make_context_for_future</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="nb">id</span><span class="p">)</span>
        <span class="n">future</span><span class="p">.</span><span class="n">poll</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
    <span class="n">sleep</span>
</pre></table></code></div></div><p>Each of the future objects for my robot boils down to a <code class="language-plaintext highlighter-rouge">Waiter</code> object, which just registers an “compare” value with the AVR Timer0 object, which will trigger an interrupt when that value is hit. When a certain number of milliseconds have passed, the comparator interrupt looks at the future ID stored in the pending future and passes that along to the executor so that it can wake the task up and do some more more work (spoiler warning: we have to patch <code class="language-plaintext highlighter-rouge">llvm</code> to get this to produce correct assembly code):</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">TIMER0_COMPA</span><span class="p">():</span>  <span class="c1"># interrupt
</span>    <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">waiting_futures</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">current_time</span> <span class="o">&gt;=</span> <span class="n">future</span><span class="p">.</span><span class="n">wake_time</span><span class="p">:</span>
            <span class="n">future</span><span class="p">.</span><span class="n">wake</span><span class="p">()</span>
</pre></table></code></div></div><p>From here, the executor wakes up and <code class="language-plaintext highlighter-rouge">poll</code>s all of the waiting futures, and the cycle continues. Along the way, we’ll discover at least one more compiler bug before we get everything working! But we will get there, I promise.</p><details> <summary>click to expand</summary><figure> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/assets/img/posts/2020-12-21/rustybot.gif" /><figcaption>Just in case you were wondering, this is where we're going. Next stop: world domination!!!!</figcaption></figure></details><p>Thanks for reading,</p><p>~drmorr</p><div class="footnotes" role="doc-endnotes"><ol><li id="fn:1" role="doc-endnote"><p>I’m always going to include the fully-namespaced types in these posts so it’s clear what you need to <code class="language-plaintext highlighter-rouge">use</code> to replicate this. Also, since I’m targeting AVR, which doesn’t support <code class="language-plaintext highlighter-rouge">std</code>, I’m using the <code class="language-plaintext highlighter-rouge">core</code> library for everything. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p><li id="fn:2" role="doc-endnote"><p>Fun fact: when you only have 2KB of RAM, maybe don’t allocate half of it for your heap, or you’re gonna start overwriting your stack eventually. That was a fun bug to track down. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >rust</a> <a href="/tags/robots/" class="post-tag no-text-decoration" >robots</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Introducing Rustybot (part 1 of n) - Object Disoriented&url=https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Introducing Rustybot (part 1 of n) - Object Disoriented&u=https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Introducing Rustybot (part 1 of n) - Object Disoriented&url=https://objectdisoriented.evokewonder.com/posts/introducing-rustybot-part-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/introducing-rustybot-part-1/">Introducing Rustybot (part 1 of n)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/robots/">robots</a> <a class="post-tag" href="/tags/rust/">rust</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/introducing-rustybot-part-2/"><div class="card-body"> <span class="timeago small" > Jan 4 <i class="unloaded">2021-01-04T23:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Introducing Rustybot (part 2 of n)</h3><div class="text-muted small"><p> N.B. This is the second part of a series about programming an arduino robot using Rust’s async primitives (Part 1, 2). If you just want to skip to the source code, click here. PSA: click on a...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled"><p>-</p></span> <a href="/posts/introducing-rustybot-part-2/" class="btn btn-outline-primary"><p>Introducing Rustybot (part 2 of n)</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://evokewonder.com">David R. Morrison</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/robots/">robots</a> <a class="post-tag" href="/tags/rust/">rust</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://objectdisoriented.evokewonder.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
